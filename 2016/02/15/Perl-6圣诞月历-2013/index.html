<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|monospace:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="圣诞," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="2013
Heredocs, Theredocs, Everywheredocs docs
So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like somethin">
<meta property="og:type" content="article">
<meta property="og:title" content="Perl 6 圣诞月历-(2013)">
<meta property="og:url" content="https://ohmycloud.github.io/2016/02/15/Perl-6圣诞月历-2013/index.html">
<meta property="og:site_name" content="Perl 6 青春小站">
<meta property="og:description" content="2013
Heredocs, Theredocs, Everywheredocs docs
So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like somethin">
<meta property="og:updated_time" content="2016-10-24T07:27:34.625Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Perl 6 圣诞月历-(2013)">
<meta name="twitter:description" content="2013
Heredocs, Theredocs, Everywheredocs docs
So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like somethin">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://ohmycloud.github.io/2016/02/15/Perl-6圣诞月历-2013/"/>

  <title> Perl 6 圣诞月历-(2013) | Perl 6 青春小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Perl 6 青春小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>
 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Perl 6 圣诞月历-(2013)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-15T00:00:00+08:00" content="2016-02-15">
              2016-02-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Perl-6/" itemprop="url" rel="index">
                    <span itemprop="name">Perl 6</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/15/Perl-6圣诞月历-2013/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/15/Perl-6圣诞月历-2013/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="2013"><a href="#2013" class="headerlink" title="2013"></a>2013</h1><hr>
<h2 id="Heredocs-Theredocs-Everywheredocs-docs"><a href="#Heredocs-Theredocs-Everywheredocs-docs" class="headerlink" title="Heredocs, Theredocs, Everywheredocs docs"></a>Heredocs, Theredocs, Everywheredocs docs</h2><hr>
<p>So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like something you really shouldn’t be doing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sub USAGE &#123;</div><div class="line">    say &quot;foobar Usage:</div><div class="line">./foobar &lt;args&gt; &lt;file&gt;</div><div class="line"></div><div class="line">Options:</div><div class="line"></div><div class="line">...</div><div class="line">&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>Perl 6 has a much better idea for you, fortunately: heredocs! They work a bit differently from Perl 5, and are now invoked using the adverb :heredoc on quoting constructs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:heredoc/END/;</div><div class="line">Hello world!</div><div class="line">END</div></pre></td></tr></table></figure>
<p>When you use :heredoc, the contents of the string are no longer the final contents; they become the string that signifies the end of a heredoc. q”END” results in the string “END”, q:heredoc”END”results in everything before the next END to appear on its own line.<br>You will have also noticed that heredocs only start on the next possible line for them to start, not immediately after the construct closes. That semicolon after the construct never gets picked up as part of a heredoc, don’t worry :) .<br>The :heredoc adverb is nice, but it seems a bit long, doesn’t it? Luckily it has a short form, :to, which is much more commonly used. So that’s what we’ll be using through the rest of the post.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:to&quot;FIN&quot;;</div><div class="line">Hello again.</div><div class="line">FIN</div></pre></td></tr></table></figure>
<p>You can use any sort of string for the delimiter, so long as there’s no leading whitespace in it. A null delimiter (q:to//) is fine too, it just means you end the heredoc with two newlines, effectively a blank line.<br>And yes, delimiters need to be on their own line. This heredoc never ends:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">say q:to&quot;noend&quot;;</div><div class="line">HELLO WORLD noend</div></pre></td></tr></table></figure>
<p>A note about indentation: look at this heredoc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to[finished];</div><div class="line">  Hello there</div><div class="line">    everybody</div><div class="line">finished</div></pre></td></tr></table></figure>
<p>Which of those three heredoc lines decides how much whitespace is removed from the beginning of each line (and thus sets the base level of indentation)? It’s the line with the end delimiter, “finished” in the last example. Lines with more indentation than the delimiter will appear indented by however much extra space they use, and lines with less indentation will be as indented as the delimiter, with a warning about the issue.<br>(Tabs are considered to be 8 spaces long, unless you change $?TABSTOP. This usually doesn’t matter unless you mix spaces and tabs for indentation anyway though.)<br>It doesn’t matter how much the delimiter indentation is, all that matters is indentation relative to the delimiter. So these are all the same:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">HELLO</div><div class="line">  WORLD</div><div class="line">END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">    HELLO</div><div class="line">      WORLD</div><div class="line">    END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say q:to/END/;</div><div class="line">               HELLO</div><div class="line">                 WORLD</div><div class="line">               END</div></pre></td></tr></table></figure>
<p>One other thing to note is that what quoting construct you use will affect how the heredoc contents are parsed, so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:to/EOF/;</div><div class="line">$dlrs dollars and &#123;$cnts&#125; cents.</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>Interpolates nothing,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say q:to:c/EOF/;</div><div class="line">$dlrs dollars and &#123;$cnts&#125; cents.</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>Interpolates just <code>{$cnts}</code> (the :c adverb allows for interpolation of just closures), and</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say qq:to/EOF/;</div><div class="line">$dlrs dollars and &#123;$cnts&#125; cents.</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>Interpolates both <code>$dlrs</code> and <code>{$cnts}</code>.<br>Here’s the coolest part of heredocs: using more than one at once! It’s easy too, just use more than one heredoc quoting construct on the line!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">say q:to/end1/, qq:to/end2/, Q:to/end3/;</div><div class="line">This is q.\\Only some backslashes work though\t.</div><div class="line">$sigils don&apos;t interpolate either.</div><div class="line">end1</div><div class="line">This is qq. I can $interpolate-sigils as well as \\ and \t.</div><div class="line">Neat, yes?</div><div class="line">end2</div><div class="line">This is Q. I can do \\ no \t such $things.</div><div class="line">end3</div></pre></td></tr></table></figure>
<p>Which, assuming you’ve defined $interpolate-sigils to hold the string “INTERPOLATE SIGILS”, prints out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">This is q.\Only some backslashes work though\t.</div><div class="line">$sigils don&apos;t interpolate either.</div><div class="line">This is qq. I can INTERPOLATE SIGILS as well as \ and   .</div><div class="line">Neat, yes?</div><div class="line">This is Q. I can do \\ no \t such $things.</div></pre></td></tr></table></figure>
<p>After every end delimiter, the next heredoc to look for its contents starts.<br>Of course, indentation of different heredocs will help whenever you have to stack a bunch of them like this.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">say qq:to/ONE/, qq:to/TWO/, qq:to/THREE/, qq:to/ONE/;</div><div class="line">The first one.</div><div class="line">ONE</div><div class="line">    The second one.</div><div class="line">    TWO</div><div class="line">The third one.</div><div class="line">THREE</div><div class="line">    The fourth one.</div><div class="line">    ONE</div></pre></td></tr></table></figure>
<p>Which outputs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The first one.</div><div class="line">The second one.</div><div class="line">The third one.</div><div class="line">The fourth one.</div></pre></td></tr></table></figure>
<p>(And yes, you don’t have to come up with a unique end delimiter every time. That could have been four <code>q:to/EOF/</code> statements and it’d still work.)<br>One final note you should be aware of when it comes to heredocs. Like the rest of Perl 6 (barring a couple of small exceptions), heredocs are read using one-pass parsing (this means your Perl 6 interpreter won’t re-read or skip ahead to better understand the code you wrote). For heredocs this means Perl 6 will just wait for a newline to start reading heredoc data, instead of looking ahead to try and find the heredoc.<br>As long as the heredoc contents and the statement that introduces the heredoc are part of the same compilation unit, everything’s fine. In addition to what you’ve seen so far, you can even do stuff like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub all-info &#123; return q:to/END/ &#125;</div><div class="line"></div><div class="line">This is a lot of important information,</div><div class="line">and it is carefully formatted.</div><div class="line">END</div></pre></td></tr></table></figure>
<p>(If you didn’t put the brace on the same line, it would be part of the heredoc, and then you’d need another brace on a line afterEND.)<br>However, things like BEGIN blocks start compiling before normal code, so trying that last one with BEGIN block fails:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; say q:to/END/ &#125;</div><div class="line">This is only the BEGINning.</div><div class="line">END</div></pre></td></tr></table></figure>
<p>You have to put the heredoc inside the BEGIN block, with the quoting construct, in order to place them in the same compilation unit.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    say q:to/END/;</div><div class="line">    This is only the BEGINning.</div><div class="line">    END</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>That’s it for heredocs! When should you use them? I would say whenever you need to type a literal newline (by hitting Enter) into the string. Help output from the USAGE sub is probably the most common case. The one at the beginning could easily (and more readably) be written as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sub USAGE &#123;</div><div class="line">    say q:to&quot;EOHELP&quot;;</div><div class="line">        foobar Usage:</div><div class="line">        ./foobar &lt;args&gt; &lt;file&gt;</div><div class="line"></div><div class="line">        Options:</div><div class="line"></div><div class="line">        ...</div><div class="line">        EOHELP</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Parsing-and-generating-recurring-dates"><a href="#Parsing-and-generating-recurring-dates" class="headerlink" title="Parsing and generating recurring dates"></a>Parsing and generating recurring dates</h2><hr>
<p>By Moritz<br>There are a lot of events that are scheduled on particular days of the week each month, for example the regular Windows Patch Day on the second Tuesday of each month, or in Perl 6 land that Rakudo Perl 6 compiler release, which is scheduled for two days after the Parrot release day, which again is scheduled for the third Tuesday of the month.<br>So let’s write something that calculates those dates.<br>The specification format I have chosen looks like 3rd tue + 2 for the Rakudo release date, that is, two days after the 3rd Tuesday of each month (note that this isn’t always the same as the 3rd Thursday).<br>Parsing it isn’t hard with a simple grammar:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">grammar DateSpec::Grammar &#123;</div><div class="line">    rule TOP &#123;</div><div class="line">        [&lt;count&gt;&lt;.quant&gt;?]?</div><div class="line">        &lt;day-of-week&gt;</div><div class="line">        [&lt;sign&gt;? &lt;offset=count&gt;]?</div><div class="line">    &#125;</div><div class="line">    token count &#123; \d+ &#125;</div><div class="line">    token quant &#123; st | nd | rd | th &#125;</div><div class="line">    token day-of-week &#123; :i</div><div class="line">        [ mon | tue | wed | thu | fri | sat | sun ]</div><div class="line">    &#125;</div><div class="line">    token sign &#123; &apos;+&apos; | &apos;-&apos; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>As you can see, everything except the day of the week is optional, so sun would simply be the first Sunday of the month, and 2 sun - 1 the Saturday before the second Sunday of the month.<br>Now it’s time to actually turn this specification into a data structure that does something useful. And for that, a class wouldn’t be a bad choice:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">my %dow = (mon =&gt; 1, tue =&gt; 2, wed =&gt; 3, thu =&gt; 4,</div><div class="line">        fri =&gt; 5, sat =&gt; 6, sun =&gt; 7);</div><div class="line"></div><div class="line">class DateSpec &#123;</div><div class="line">    has $.day-of-week;</div><div class="line">    has $.count;</div><div class="line">    has $.offset;</div><div class="line"></div><div class="line">    multi method new(Str $s) &#123;</div><div class="line">        my $m = DateSpec::Grammar.parse($s);</div><div class="line">        die &quot;Invalid date specification &apos;$s&apos;\n&quot; unless $m;</div><div class="line">        self.bless(</div><div class="line">            :day-of-week(%dow&#123;lc $m&lt;day-of-week&gt;&#125;),</div><div class="line">            :count($m&lt;count&gt; ?? +$m&lt;count&gt;[0] !! 1),</div><div class="line">            :offset( ($m&lt;sign&gt; eq &apos;-&apos; ?? -1 !! 1)</div><div class="line">                    * ($m&lt;offset&gt; ?? +$m&lt;offset&gt; !! 0)),</div><div class="line">        );</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>We only need three pieces of data from those date specification strings: the day of the week, whether the 1st, 2nd, 3rd. etc is wanted (here named $.count), and the offset. Extracting them is a wee bit fiddly, mostly because so many pieces of the grammar are optional, and because the grammar allows a space between the sign and the offset, which means we can’t use the Perl 6 string-to-number conversion directly.<br>There is a cleaner but longer method of extracting the relevant data using an actions class.<br>The closing } is missing, because the class doesn’t do anything useful yet, and that should be added. The most basic operation is to find the specified date in a given month. Since Perl 6 has no built-in type for months, we use a Date object where the .day is one, that is, a Date object for the first day of the month.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">method based-on(Date $d is copy where &#123; .day == 1&#125;) &#123;</div><div class="line">     ++$d until $d.day-of-week == $.day-of-week;</div><div class="line">     $d += 7 * ($.count - 1) + $.offset;</div><div class="line">     return $d;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>The algorithm is quite simple: Proceed to the next date (++$d) until the day of week matches, then advance as many weeks as needed, plus as many days as needed for the offset. Date objects support addition and subtraction of integers, and the integers are interpreted as number of days to add or subtract. Handy, and exactly what we need here. (The API is blatantly copied from theDate::Simple Perl 5 module).<br>Another handy convenience method to implement is next, which returns the next date matching the specification, on or after a reference date.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    method next(Date $d = Date.today) &#123;</div><div class="line">        my $month-start = $d.truncated-to(month);</div><div class="line">        my $candidate   = $.based-on($month-start);</div><div class="line">        if $candidate ge $d &#123;</div><div class="line">            return $candidate;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return $.based-on($month-start + $month-start.days-in-month);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Again there’s no rocket science involved: try the date based on the month of $d, and if that’s before $d, try again, but with the next month as base.<br>Time to close the class :-).<br>So, when is the next Rakudo release? And the next Rakudo release after Christmas?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my $spec = DateSpec.new(&apos;3rd Tue + 2&apos;);</div><div class="line">say $spec.next;</div><div class="line">say $spec.next(Date.new(2013, 12, 25));</div></pre></td></tr></table></figure>
<p>Output:<br>2013-12-19<br>2014-01-23</p>
<p>The code works fine on Rakudo with both the Parrot and the JVM backend.<br>Happy recurring hollidates!</p>
<h2 id="Hashes-and-pairs"><a href="#Hashes-and-pairs" class="headerlink" title="Hashes and pairs"></a>Hashes and pairs</h2><hr>
<p>Hashes are nice. They can work as a kind of “poor man’s objects” when creating a class seems like just too much ceremony for the occasion.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $employee = &#123;</div><div class="line">    name =&gt; &apos;Fred&apos;,</div><div class="line">    age =&gt; 51,</div><div class="line">    skills =&gt; &lt;sweeping accounting barking&gt;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>花括号可以省略:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %employee =</div><div class="line">    name =&gt; &apos;Fred&apos;,</div><div class="line">    age =&gt; 51,</div><div class="line">    skills =&gt; &lt;sweeping accounting barking&gt;,</div><div class="line">;</div></pre></td></tr></table></figure>
<p>散列的最后一项的末尾可以添加一个逗号。<br>Hashes make great “configuration objects”, too. You want to pass some options into a routine somewhere, but the options (for reasons of future compatibility, perhaps) need to be an open set.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my %options =</div><div class="line">    rpm =&gt; 440,</div><div class="line">    duration =&gt; 60,</div><div class="line">;</div><div class="line">$centrifuge.start(%options);</div></pre></td></tr></table></figure>
<p>Actually, we have two options with that last line. Either we pass in the whole hash like that, and the method in the centrifuge class will need to look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">method start(%options) &#123;</div><div class="line">    # probably need to start by unpacking options here</div><div class="line">    # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Or we decide to “gut” the hash as we pass it in, effectively turning it into a bunch of named arguments:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$centrifuge.start( |%options );  # means :rpm(440), :duration(60)</div></pre></td></tr></table></figure>
<p>强制参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">method start(:$rpm!, :$duration!) &#123;</div><div class="line">    # ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(In this case, we probably want to put in those exclamation marks, to make those named parameters obligatory. Unless we’re fine with providing some of them with a default, such as <code>:$duration = 120</code>.)</p>
<p>前缀操作符 <code>prefix:&lt;|&gt;</code> 其实叫做“展开” 或 “插值”。 在 Perl 6 中， 数组被展开为位置参数，散列被展开为命名参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my @args = &quot;Would you like fries with that?&quot;, 15, 5;</div><div class="line">say substr(|@args);    # fries</div><div class="line"></div><div class="line">my %details = :year(1969), :month(7), :day(16),</div><div class="line">              :hour(20),     :minute(17);</div><div class="line">my $moonlanding = DateTime.new( |%details );</div></pre></td></tr></table></figure>
<p>Perl 6 散列的项真的很像命名参数。当然它们不是， 它们只是散列中的键和值。但确实太像了。我们有 2 种语法来写一个散列的项。 一个是 胖箭头 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %opts = blackberries =&gt; 42;</div></pre></td></tr></table></figure>
<p>一个是命名参数语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %opts = :blackberries(42);</div></pre></td></tr></table></figure>
<p>他们俩各有千秋。 后者比较 nice 的是它能够混合变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my $blackberries = 42;</div><div class="line">my %opts = :$blackberries;   # 等价于  :blackberries($blackberries)</div></pre></td></tr></table></figure>
<p>如果不重复单词 blackberries，使用 胖箭头语法就做不到了。</p>
<p>所以散列的项（一个键+一个键值）在 Perl 6 中变的更像一个东西。<br>在 Perl 6 中， 通过使用  <code>:blackberries(42)</code> 语法 或  <code>:$blackberries</code> 语法，让散列的项更突出。不仅如此， 把散列传递到子例程中时也是一项一项传递烦人，这让项更加突出。<br>最后，我们妥协了，意识到这样一串散列的项可以作为一个单位， 所以我们给它一个名字叫 Pair。散列是由一串串 Pair 对象（无序的）组成的。<br>所以，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say %employee.elems;</div></pre></td></tr></table></figure>
<p>打印出 “3″… 这就是散列 <code>%employee</code> 中 Pair 对象的数量。</p>
<p>But in the end, Pair objects even turn out to have a sort of independent existence, graduating from their role as hash constituents. For, example, you can treat them as cons pairs and simulate Lisp lists with them:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $lisp-list = 1 =&gt; 2 =&gt; 3 =&gt; Nil;  # it&apos;s nice that infix:&lt;&lt; =&gt; &gt;&gt; is right-associative</div></pre></td></tr></table></figure>
<p>And then, as a final trick, let’s dynamically extend the Pair class to recognize arbitrary cadr-like method calls. (Note that.^add_fallback is not in the spec and currently Rakudo-only.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Pair.^add_fallback(</div><div class="line">    -&gt; $, $name &#123; $name ~~ /^c&lt;[ad]&gt;+r$/ &#125;,  # should we handle this? yes, if /^c&lt;[ad]&gt;+r$/</div><div class="line">    -&gt; $, $name &#123;                            # if it turned out to be our job, this is what we do</div><div class="line">        -&gt; $p &#123;</div><div class="line">            $name ~~ /^c(&lt;[ad]&gt;*)(&lt;[ad]&gt;)r$/;        # split out last &apos;a&apos; or &apos;d&apos;</div><div class="line">            my $r = $1 eq &apos;a&apos; ?? $p.key !! $p.value;    # choose key or value</div><div class="line">            $0 ?? $r.&quot;c&#123;$0&#125;r&quot;() !! $r;                            # maybe recurse</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line">$lisp-list.caddr.say;    # 3</div></pre></td></tr></table></figure>
<p>Whee!</p>
<h2 id="Adverbly-Adverby-Adverbs"><a href="#Adverbly-Adverby-Adverbs" class="headerlink" title="Adverbly Adverby Adverbs"></a>Adverbly Adverby Adverbs</h2><hr>
<p>By Lueinc<br>两种创建Pair对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %h = debug =&gt; True;</div></pre></td></tr></table></figure>
<p>还有一种是冒号记法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my %h = :debug(True);</div></pre></td></tr></table></figure>
<p>今天，我会向你展示冒号记法是如何有用，Perl 6将它们用作主要的语言特性<br>什么是副词？<br>在自然语言中，副词没有动词与形容词的意思变化的明显。例如<br>The dog fetched the stick.                               # 狗叼回了棒子<br>仅仅是狗所做的表现。通过加上副词，例如:<br>The dog quickly fetched the stick.          # 狗很快地叼回了棒子<br>声明狗能在很短的时间完成这件事。副词能让变化很激烈，就像看到的：<br>This batch of cookies was chewy.                # 饼干很难嚼<br>This batch of cookies was oddly chewy.  # 饼干极其难嚼<br>第二个句子，使用副词 “oddly”，让你知道那饼干不是面包师的目标。Perl6中的副词表现的跟上面的任务很像，告诉函数和其它语言特性做它们想做的<br>副词基础<br>副词是使用冒号+副词的语法来表达的。通常，你将它们用作开关。<br>开启副词的方式就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:adverb</div></pre></td></tr></table></figure>
<p>它和这一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:adverb(True)</div></pre></td></tr></table></figure>
<p>关闭副词长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:!adverb</div></pre></td></tr></table></figure>
<p>它就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:adverb(False)</div></pre></td></tr></table></figure>
<p>如果你传递的是字符串直接量，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:greet(&apos;Hello&apos;)</div><div class="line">:person(&quot;$user&quot;)</div></pre></td></tr></table></figure>
<p>你可以用下面的代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:greet&lt;Hello&gt;</div><div class="line">:person«$user» or :person&lt;&lt;$user&gt;&gt;</div></pre></td></tr></table></figure>
<p>只要字符串中没有空格（尖括号形式实际上创建一列项，用空格分隔）<br>你也可以缩写变量如果变量的名字和键的名字相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:foo($foo)</div><div class="line">:$foo</div></pre></td></tr></table></figure>
<p>如果你提供一个十进制数，有两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:th(4)</div><div class="line">:4th</div></pre></td></tr></table></figure>
<p>(The :4th form only works on quoting construct adverbs, like <code>m//</code>and <code>q[]</code>, in Rakudo at the moment.)<br>注意，副词的反义形式 (<code>:!adv</code>) 和 符号形式 (<code>:$foo</code>, <code>:@baz</code>) 不能给予值， 因为你已经给了它一个值了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; my $foo = &apos;Fooo&apos;; my $bar = &apos;Barrr&apos;;</div><div class="line">Fooo</div><div class="line">Barrr</div><div class="line">&gt; my %h = :$foo, :$bar;</div><div class="line">bar =&gt; Barrr, foo =&gt; Fooo</div><div class="line">&gt; say %h&lt;foo&gt;;</div><div class="line">Fooo</div></pre></td></tr></table></figure>
<p>函数调用中的副词<br>函数调用中的副词用法更像具名参数，但仍计为副词。<br>下面是例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo($z, :adverbly);</div><div class="line">foo($z, :bar, :baz);</div><div class="line">foo($z, :bar :baz);</div></pre></td></tr></table></figure>
<p>每个副词都是一个具名参数，所以使用多个逗号分隔每个副词，就像分隔其它参数一样。注意你也可以像最后一个例子中一样，允许你叠加副词。<br>作用在操作符上的副词</p>
<p>副词能作用于操作符上，就像它们在函数中做的那样。它们优先级比项的赋值高，比条件的优先级低。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo($z) :bar :baz  # 等价于 foo($z, :bar, :baz)</div><div class="line">1 / 3 :round       # applies to /</div><div class="line">$z &amp; $y :adverb    # applies to &amp;</div></pre></td></tr></table></figure>
<p>When it comes to more complex cases, it’s helpful to remember that adverbs work similar to how an infix operator at that precedence level would (if it helps, think of the colon as a double bond in chemistry, binding both “sides” of the infix to the left-hand side). It operates on the loosest precedence operator no looser than adverbs.当情况复杂的时候， 记住副词与中缀操作符在那个优先级上的效果相似（如果有用，把冒号看作化学里面的双键（如H2C=CH2(乙烯)。碳原子与碳原子C=C以双键结合。）把中缀操作符的两侧绑定到左边）它作用于优先级最低（比副词优先级高）的操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 || 2 &amp;&amp; 3 :adv   # applies to ||</div><div class="line">1 || (2 &amp;&amp; 3 :adv) # applies to &amp;&amp;</div><div class="line">!$foo.bar() :adv   # applies to !</div><div class="line">!($foo.bar() :adv) # applies to .bar()</div><div class="line">@a[0..2] :kv       # applies to []</div><div class="line">1 + 2 - 3 :adv     # applies to -</div><div class="line">1 ** 2 ** 3 :adv   # applies to the leftmost **</div></pre></td></tr></table></figure>
<p>Notice that the behavior of adverbs on operators looser than adverbs is currently undefined.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 || 2 and 3 :adv  # error (&apos;and&apos; too loose, applies to 3)</div><div class="line">1 and 2 || 3 :adv  # applies to ||</div></pre></td></tr></table></figure>
<p>作用在引号结构上的副词</p>
<p>各种引号那样的结构也通过副词改变行为。<br>(注意：这儿没有提供副词的详尽信息。 S02 和 S05 里面有更详细的介绍)<br>例如，让一个引号结构表现为单引号并插值闭包， 则你需要写成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">q:c &apos;Hello, $name. You have &#123; +@msgs &#125; messages.&apos;</div><div class="line">#  是的，字符 c 和 字符 &apos; 之间需要空格</div></pre></td></tr></table></figure>
<p>这会输出：Hello, <code>$name</code>. You have 12 messages.<br>(这表明@msgs 数组有12个元素)<br>如果你想让双引号结构不插值标量，你会使用副词 :s 的反义形式 :!s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">qq:!s &apos; ... etc ...&apos;</div></pre></td></tr></table></figure>
<p>正则 Regexes 允许你在 regex 外部使用副词之外， 还允许你在 regex 内部使用副词。在某些不能使用副词的情况下，内部副词允许你使用那些副词带来的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$a ~~ m:i/HELLO/; # matches HELLO, hello, Hello ...</div><div class="line">$a ~~ /:i HELLO/; # same</div><div class="line">regex Greeting &#123;</div><div class="line">    :i HELLO</div><div class="line">&#125;                 # same</div></pre></td></tr></table></figure>
<p>要记住的是作用在引号结构上的副词必须使用圆括号来传递值。这是因为，通常出现在副词后面的括号会被作为值传递给副词，这与你可以选择自己的引号括号的权利冲突了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m:nth(5)// # OK</div><div class="line">m:nth[5]// # Not OK</div><div class="line">q:to(EOF)  # passing a value to :to, no delimiters found</div><div class="line">q:to (EOF) # string delimited by ()</div></pre></td></tr></table></figure>
<p>使用你自己的副词<br>所以你决定给你的函数添加你自己定义的副词。如果你记得的话，副词和具名参数基本上是一样的东西。所以，为了给你的函数创建副词，你仅仅只需要声明具名参数就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub root3($number, :$adverb1, :$adverb2) &#123;</div><div class="line">    # ... snip ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给副词一个默认值就和位置参数一样，并且让某个副词必须出现，只需在副词名后面添加一个感叹号就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sub root4($num, :$adv1 = 42, :$adv2, :$adv3!) &#123;</div><div class="line">    # default value of $adv1 is 42,</div><div class="line">    # $adv2 is undefined (boolifies to False)</div><div class="line">    # $adv3 must be supplied by the user</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想捕捉别人扔给你的所有副词，你可以使用 slurpy 散列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sub root3($num, *%advs) &#123;</div><div class="line">    # %advs 包含所有传递给该函数的副词 :adverbs</div><div class="line">    # that were passed to the function.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你在MAIN子例程定义了具名参数，它们会变成命令行选项！<br>操作符也是一样，因为操作符就是特殊语法的函数！<br>既然你已经学会了怎样把简陋的 Pair 应用到更多不止 Hashes 上面， 我希望你能在你的代码中快速使用它们， 并愉快地阅读剩下的 advent！</p>
<h2 id="Slicing-with-adverbs-the-only-way"><a href="#Slicing-with-adverbs-the-only-way" class="headerlink" title="Slicing with adverbs, the only way!"></a>Slicing with adverbs, the only way!</h2><hr>
<p>By Liztormato<br>在散列切片和数组切片中你能使用哪些副词呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">名称	            描述</div><div class="line">:exists	元素是否存在</div><div class="line">:delete	移除元素，返回真，如果有元素被移除的话</div><div class="line">:kv	            将键和值作为Parcel返回</div><div class="line">:p	            return key(s) and value(s) as Parcel of Pairs</div><div class="line">:k	          只返回键</div><div class="line">:v	          只返回值</div></pre></td></tr></table></figure>
<p><code>:exists</code><br>这个副词代替 <code>.exists</code>方法。 副词为散列和数组提供了统一的接口，可以一次检查多个元素。 .exists方法只允许一次检查单个键。<br>例子更有说服力。检查单个键是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a&gt;:exists’</div><div class="line">True</div></pre></td></tr></table></figure>
<p>如果我们将这扩展到切片上，我们会得到一堆布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:exists&apos;</div><div class="line">True True False</div></pre></td></tr></table></figure>
<p>返回结果是 （Parcel）<br>注意，如果我们仅仅请求一个键，我们取回的是一个布尔值，不是一个只含一个布尔值的Parcel.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say (%h&lt;a&gt;:exists).WHAT’</div><div class="line">(Bool)</div></pre></td></tr></table></figure>
<p>如果很清楚地知道我们是在处理多个键，或者在编译时不清楚我们仅仅处理单个键，我们得到 一个 Parcel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say (%h&lt;a b c&gt;:exists).WHAT’</div><div class="line">(Parcel)</div><div class="line">$ perl6 -e &apos;my @a=&quot;a&quot;; my %h = a=&gt;1, b=&gt;2; say (%h&#123;@a&#125;:exists).WHAT&apos;</div><div class="line">(Parcel)</div></pre></td></tr></table></figure>
<p>有时，知道某些东西不存在更方便。你可以很方便的在副词前面前置一个 叹号 ! 来反转副词 ，无论如何，它们其实真的很像具名参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;c&gt;:!exists&apos;</div><div class="line">True</div></pre></td></tr></table></figure>
<p><code>:delete</code><br>只有这个副词能改变散列或数组，它代替的是 .delete方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a&gt;:delete; say %h.perl&apos;</div><div class="line">(&quot;b&quot; =&gt; 2).hash</div></pre></td></tr></table></figure>
<p>当然，你也可以删除切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete; say %h.perl&apos;</div><div class="line">1 2 (Any)</div><div class="line">().hash</div></pre></td></tr></table></figure>
<p>注意对于一个不存在的值会返回 (Any)，如果你碰巧给定散列一个默认的值，它会长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h is default(42) = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete; say %h.perl&apos;</div><div class="line">1 2 42</div><div class="line">().hash</div></pre></td></tr></table></figure>
<p>像 <code>:exists</code> 一样，你可以反转 <code>:delete</code> 副词，但是没有太多意义。因为副词本质上是具名参数，你可以让:delete属性带条件参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my $really = True; my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete($really); say %h.perl&apos;</div><div class="line">1 2 (Any)</div><div class="line">().hash</div></pre></td></tr></table></figure>
<p>因为传递给副词的值是真的，删除才真正发生。然而，如果你传递一个假值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e ‘my $really; my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete($really); say %h.perl&apos;</div><div class="line">1 2 (Any)</div><div class="line">(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2).hash</div></pre></td></tr></table></figure>
<p>它没有删除。注意返回值没有变化。删除操作就没有执行。如果你使用子例程或方法处理一些常规的切片，这会很方便，并且，你想用一个可选参数表明切片是否也被删除：仅仅将参数传递为副词的参数！</p>
<p>:kv, :p, :k, :v<br>kv 属性返回键值对，  :p属性返回一对Parcel， :k 和 :v属性只返回键和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ perl6</div><div class="line">&gt; my %h = a =&gt; 1, b =&gt; 2;</div><div class="line">(&quot;a” =&gt; 1, &quot;b” =&gt; 2).hash</div><div class="line">&gt; %h&lt;a&gt;:kv</div><div class="line">a 1</div><div class="line">&gt; %h&lt;a&gt;:p  # 注意:p 返回的是 Parcel</div><div class="line">&quot;a&quot; =&gt; 1</div><div class="line">&gt; %h&lt;a&gt;:k</div><div class="line">a</div><div class="line">&gt; %h&lt;a&gt;:v</div><div class="line">1</div></pre></td></tr></table></figure>
<p>注意下面返回值的不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; %h&lt;a b c&gt;</div><div class="line">1 2 (Any)</div><div class="line">&gt; %h&lt;a b c&gt;:v</div><div class="line">1 2</div></pre></td></tr></table></figure>
<p>因为 :v 属性起着过滤的作用，过滤掉 Any. 但是，有时候你不需要这种行为。反转那个属性就可以达到目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; %h&lt;a b c&gt;:k</div><div class="line">a b</div><div class="line">&gt; %h&lt;a b c&gt;:!k</div><div class="line">a b c</div></pre></td></tr></table></figure>
<p>将副词组合在一块<br>你也可以将几个副词结合在一块作用到 散列或切片上。最有用的组合是用 :exist 和:delete中的一个或两个，结合 :kv, :p, :k, :v中的其中之一。一些例子，例如将散列中的切片放到另外一个散列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; my %i = (%h&lt;a c&gt;:delete:p).list; say %h.perl; say %i.perl&apos;  # delete返回删除的东西</div><div class="line">(&quot;b” =&gt; 2).hash</div><div class="line">(&quot;a” =&gt; 1).hash</div></pre></td></tr></table></figure>
<p>下面返回的是删除掉的键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my %h = a=&gt;1, b=&gt;2; say %h&lt;a b c&gt;:delete:k’</div><div class="line">a b</div></pre></td></tr></table></figure>
<p>数组不是散列<br>在数组中，元素的键是数组的索引，所以，显示数组中定义有值的元素的索引，我们可以使用 :k属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my @a; @a[3] = 1; say @a[]:k&apos;</div><div class="line">3</div></pre></td></tr></table></figure>
<p>或使用数组中的所有元素创建一个 Parcel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my @a; @a[3] = 1; say @a[]:!k’</div><div class="line">0 1 2 3</div></pre></td></tr></table></figure>
<p>然而，从数组中删除一个元素，和把 Nil 赋值给它类似，所以它会返回它默认的值（通常是 (Any))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; my @a=^10;</div><div class="line">0 1 2 3 4 5 6 7 8 9</div><div class="line">$ perl6 -e &apos;my @a = ^10; @a[3]:delete; say @a[2,3,4]; say @a[2,3,4]:exists&apos;</div><div class="line">2 (Any) 4</div><div class="line">True False True</div></pre></td></tr></table></figure>
<p>如果我们给数组指定了默认值，结果会稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ perl6 -e &apos;my @a is default(42) = ^10; @a[3]:delete; say @a[2,3,4]; say @a[2,3,4]:exists&apos;</div><div class="line">2 42 4</div><div class="line">True False True</div></pre></td></tr></table></figure>
<p>所以，即使元素不存在了，它也能返回一个定义好的值</p>
<h2 id="A-Grammar-with-duplicate-checking"><a href="#A-Grammar-with-duplicate-checking" class="headerlink" title="A Grammar with duplicate checking"></a>A Grammar with duplicate checking</h2><hr>
<p>By Dwarring<br>今天的例子构建了一个 grammar 用于追踪打牌。一个或多个玩家， 每个玩家手上只有 5 张牌。每次发牌不允许有重复纸牌：</p>
<p>A simple Card Game Grammar<br>To start with, here’s the basic grammar (no duplicate checks yet):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">grammar CardGame &#123;</div><div class="line"></div><div class="line">    rule TOP &#123; ^ &lt;deal&gt; $ &#125;</div><div class="line"></div><div class="line">    rule deal &#123;</div><div class="line">        &lt;hand&gt;+ % &apos;;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rule hand  &#123; [ &lt;card&gt; ]**5 &#125;</div><div class="line">    token card &#123; &lt;face&gt;&lt;suit&gt;  &#125;</div><div class="line"></div><div class="line">    proto token suit &#123;*&#125;</div><div class="line">    token suit:sym&lt;♥&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♦&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♣&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line">    token suit:sym&lt;♠&gt;  &#123;&lt;sym&gt;&#125;</div><div class="line"></div><div class="line">    token face &#123;:i &lt;[2..9]&gt; | 10 | j | q | k | a &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">say CardGame.parse(&quot;2♥ 5♥ 7♦ 8♣ 9♠&quot;);</div><div class="line">say CardGame.parse(&quot;2♥ a♥ 7♦ 8♣ j♥&quot;);</div></pre></td></tr></table></figure>
<p>最高阶层的 rule 包含一个 deal （发牌）。 deal 由一个或多个使用 ; 隔开的 hands（一手牌）组成。每手牌 hand 有 5 张纸牌。<br>每张纸牌由一个 face 和一个 suite 代表。face 有 A、J、Q、K 或 2-10. 后面跟着花色 suite：♥ (红心) ♦ (方块) ♣ (梅花) or ♠ (黑桃)。<br>[我们可以使用纸牌字符， Unicode 6.0新引入的，但是还未被广泛支持]<br>不出所料，第一茬 grammar 能就解析任意手牌：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;);</div><div class="line"># 一手, duplicate a♥</div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♥&quot;);</div><div class="line"># 两手, duplicate j♥</div></pre></td></tr></table></figure>
<p>检测重复</p>
<p>我们开始给这个 grammar 添加一个 Perl 6变量申明。这将用于追踪纸牌：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rule deal &#123;</div><div class="line">    :my %*PLAYED = ();</div><div class="line">    &lt;hand&gt;+ % &apos;;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这申明了 <code>%*PLAYED</code>。 ‘%<em>‘ twigil  表明那是一个散列， ‘</em>‘ 表明它是动态作用域的。<br>动态作用域不仅仅用于子例程和方法调用。它也能无缝地和 grammar rules、tokens和 actions 用在一起。<br>因为是动态作用域， <code>%*PLAYED</code>  对于 deal rule 的调用者是可见的； hand token 和它的调用者， card token。<br>%*PLAYED 对于任何随后被调用的 actions 也是可见的。所以通过为 card token 创建一个 action 我们能够追踪和报告重复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class CardGame::Actions &#123;</div><div class="line">    method card($/) &#123;</div><div class="line">       my $card = $/.lc;</div><div class="line">       say &quot;Hey, there&apos;s an extra $card&quot;</div><div class="line">           if %*PLAYED&#123;$card&#125;++;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">my $a = CardGame::Actions.new;</div><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;, :actions($a));</div><div class="line"># &quot;Hey there&apos;s an extra a♥&quot;</div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦&quot;,</div><div class="line">                   :actions($a));</div><div class="line"># &quot;Hey there&apos;s an extra j♥&quot;</div></pre></td></tr></table></figure>
<p>这可能就是所有用于追踪和报告重复的代码了。grammar 申明和 action 是分开的， 还有一个动态作用域的散列。</p>
<p>不接收重复<br>我们要求当出现重复时，让解析失败。把重复检查的 grammar 语法移动到里面就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">token card &#123;&lt;face&gt;&lt;suit&gt;</div><div class="line">    &lt;?&#123;</div><div class="line">        # only allow each card to appear once</div><div class="line">        my $card = $/.lc;</div><div class="line">        say &quot;Hey, there&apos;s an extra $card&quot;</div><div class="line">            if %*PLAYED&#123;$card&#125;;</div><div class="line"></div><div class="line">        ! %*PLAYED&#123;$card&#125;++;</div><div class="line">     &#125;&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这在&lt;?{ 和 }&gt;  之间引入了一个断言. 当这段代码值为 True 时， rule 就成功， 当单次发牌同一张纸牌出现多于一次时card token 失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">say CardGame.parse(&quot;2♥ 7♥ 2♦ 3♣ 3♦&quot;);</div><div class="line"># legitimate, parses</div><div class="line"></div><div class="line">say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;);</div><div class="line"># fails with message: Hey, there&apos;s an extra a♥</div><div class="line"></div><div class="line">say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦&quot;);</div><div class="line"># fails with message: Hey, there&apos;s an extra j♥</div></pre></td></tr></table></figure>
<h2 id="Unary-Sort"><a href="#Unary-Sort" class="headerlink" title="Unary Sort"></a>Unary Sort</h2><hr>
<p>By Moritz<br>在Perl5中按数值大小排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use v5;</div><div class="line">my @sorted = sort &#123; $a &lt;=&gt; $b &#125; @values;</div></pre></td></tr></table></figure>
<p>Perl6 提供类似的选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use v6;</div><div class="line">my @sorted = sort &#123; $^a &lt;=&gt; $^b &#125;, @values;</div></pre></td></tr></table></figure>
<p>主要区别在于，参数不是通过全局变量 <code>$a</code> 和 <code>$b</code> 来传递，而是作为 comparator的参数传递。 comparator 可以是任何能掉调用的东西,即具名或匿名的子例程或代码块。{ $^a &lt;=&gt; $^b}语法对于sort也不特殊，我仅仅用了占位变量来展示和Perl5 的相似之处。 下面的写法一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my @sorted = sort -&gt; $a, $b &#123; $a &lt;=&gt; $b &#125;, @values;</div><div class="line">my @sorted = sort * &lt;=&gt; *, @values;</div><div class="line">my @sorted = sort &amp;infix:«&lt;=&gt;», @values;</div></pre></td></tr></table></figure>
<p>The first one is just another syntax for writing blocks, <code>* &lt;=&gt; *</code> use* to automatically curry an argument, and the final one directly refers to the routine that implements the &lt;=&gt; “space ship” operator (which does numeric comparison).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 按照散列中定义的顺序排序单词:</div><div class="line">my %rank = a =&gt; 5, b =&gt; 2, c =&gt; 10, d =&gt; 3;</div><div class="line">say sort &#123; %rank&#123;$^a&#125; &lt;=&gt; %rank&#123;$^b&#125; &#125;, &apos;a&apos;..&apos;d&apos;;  # b d a c ,升序排列</div><div class="line"> #          ^^^^^^^^^^     ^^^^^^^^^^  code duplication</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 不区分大小写排序</div><div class="line">say sort &#123; $^a.lc cmp $^b.lc &#125;, @words;</div><div class="line"> #          ^^^^^^     ^^^^^^  代码重复</div></pre></td></tr></table></figure>
<p>因为我们酷爱便捷憎恨重复，Perl 6 提供了更短的方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># sort words by a sort order defined in a hash:</div><div class="line">say sort &#123; %rank&#123;$_&#125; &#125;, &apos;a&apos;..&apos;d&apos;;</div><div class="line"></div><div class="line"># sort case-insensitively</div><div class="line">say sort &#123; .lc &#125;, @words;</div></pre></td></tr></table></figure>
<p>sort足够聪明地知道代码块现在只有一个参数，并使用它将输入列表中的每个元素映射为新值。这与Schwartzian Transform很相似，但是很方便，因为它是内置的。所以，现在代码块起着转换者的角色，而非比较器。<br>如果你想按数字顺序比较，你可以强制元素在数字上下文中进行比较，使用 + 号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my @sorted-numerically = sort +*, @list;</div></pre></td></tr></table></figure>
<p>如果你想按相反的顺序比较数字，就使用 <code>-*</code> 代替好了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>
    
    <div>
      
        
<div style="text-align:center;color: #ccc;font-size:15px;">
------ Young For Perl 6! ------</div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/圣诞/" rel="tag">#圣诞</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/02/14/Perl-6-Examples/" rel="next" title="Perl 6 Examples">
                <i class="fa fa-chevron-left"></i> Perl 6 Examples
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/02/19/Perl6中的智能匹配/" rel="prev" title="Perl 6 中的智能匹配">
                Perl 6 中的智能匹配 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/02/15/Perl-6圣诞月历-2013/"
     data-title="Perl 6 圣诞月历-(2013)"
     data-content=""
     data-url="https://ohmycloud.github.io/2016/02/15/Perl-6圣诞月历-2013/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/02/15/Perl-6圣诞月历-2013/"
           data-title="Perl 6 圣诞月历-(2013)" data-url="https://ohmycloud.github.io/2016/02/15/Perl-6圣诞月历-2013/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="焉知非鱼" />
          <p class="site-author-name" itemprop="name">焉知非鱼</p>
          <p class="site-description motion-element" itemprop="description">Young For Perl 6</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">161</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">177</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ohmycloud" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/740011611" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/9b20c7d63b77" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-location-arrow"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://perl6.org/" target="_blank" title="Perl 6">
                  
                    <i class="fa fa-fw fa-paper-plane"></i>
                  
                  Perl 6
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2013"><span class="nav-number">1.</span> <span class="nav-text">2013</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Heredocs-Theredocs-Everywheredocs-docs"><span class="nav-number">1.1.</span> <span class="nav-text">Heredocs, Theredocs, Everywheredocs docs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parsing-and-generating-recurring-dates"><span class="nav-number">1.2.</span> <span class="nav-text">Parsing and generating recurring dates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashes-and-pairs"><span class="nav-number">1.3.</span> <span class="nav-text">Hashes and pairs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Adverbly-Adverby-Adverbs"><span class="nav-number">1.4.</span> <span class="nav-text">Adverbly Adverby Adverbs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slicing-with-adverbs-the-only-way"><span class="nav-number">1.5.</span> <span class="nav-text">Slicing with adverbs, the only way!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-Grammar-with-duplicate-checking"><span class="nav-number">1.6.</span> <span class="nav-text">A Grammar with duplicate checking</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unary-Sort"><span class="nav-number">1.7.</span> <span class="nav-text">Unary Sort</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">焉知非鱼</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  托管在 -
  <a class="theme-link" href="https://github.com/ohmycloud/ohmycloud.github.io">
    Github
  </a>
  &nbsp; | &nbsp;
</div>

<div class="theme-info">
 <a class="51-img" href="/images/footer.gif" target="_blank"><img alt="统计" src="/images/footer.gif"  align="right" /></a>
<div>
        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"chenyf"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  

</body>
</html>
