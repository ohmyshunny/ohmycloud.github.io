<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|monospace:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="面向对象," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Perl 6 有很多预先定义好的类型，这些类型可以归为 2 类：普通类型和原生类型。原生类型用于底层类型（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象的 Perl 6">
<meta property="og:url" content="https://ohmycloud.github.io/2015/06/15/面向对象的Perl6/index.html">
<meta property="og:site_name" content="Perl 6 青春小站">
<meta property="og:description" content="Perl 6 有很多预先定义好的类型，这些类型可以归为 2 类：普通类型和原生类型。原生类型用于底层类型（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。">
<meta property="og:updated_time" content="2016-10-24T07:26:10.755Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象的 Perl 6">
<meta name="twitter:description" content="Perl 6 有很多预先定义好的类型，这些类型可以归为 2 类：普通类型和原生类型。原生类型用于底层类型（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://ohmycloud.github.io/2015/06/15/面向对象的Perl6/"/>

  <title> 面向对象的 Perl 6 | Perl 6 青春小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Perl 6 青春小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>
 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                面向对象的 Perl 6
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-15T00:00:00+08:00" content="2015-06-15">
              2015-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Perl-6/" itemprop="url" rel="index">
                    <span itemprop="name">Perl 6</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/15/面向对象的Perl6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/15/面向对象的Perl6/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> Perl 6 有很多预先定义好的类型，这些类型可以归为 2 类：<code>普通类型</code>和<code>原生类型</code>。原生类型用于<code>底层类型</code>（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。</p>
 <a id="more"></a>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p>方法可以有参数， 但是方法名和参数列表之间不可以有空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">say &quot;abc&quot;.uc;                   </div><div class="line">#        ^^^ 不带参数的方法调用</div><div class="line">my @words = $string.comb(/\w+/);</div><div class="line">#                  ^^^^^^^^^^^^ 带一个参数的方法调用</div></pre></td></tr></table></figure>
<p>另外一种方法调用的语法将方法名和参数列表用一个冒号分开(冒号紧跟方法名, 中间不能有空格):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say @*INC.join: &apos;:&apos;;</div></pre></td></tr></table></figure>
<p>方法能返回一个可变容器, 这种情况下 你可以赋值给方法调用的返回值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$*IN.input-line-separator = &quot;\r\n&quot;;</div></pre></td></tr></table></figure>
<h2 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h2><p>Types本身就是对象 ，你可以使用类型的名字获取 type object :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $int-type-obj = Int;</div></pre></td></tr></table></figure>
<p>你可以通过调用 WHAT 方法查看任何对象的 type object(它实际上是一个方法形式的macro):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my $int-type-obj = 1.WHAT;</div></pre></td></tr></table></figure>
<p>使用 === 操作符可以比较 类型对象的相等性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sub f(Int $x) &#123;</div><div class="line">    if $x.WHAT === Int &#123;</div><div class="line">        say &apos;you passed an Int&apos;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        say &apos;you passed a subtype of Int&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类型可以使用 smart-matching来检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if $type ~~ Real &#123;</div><div class="line">    say &apos;$type contains Real or a subtype thereof&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>使用 class 关键字进行类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明一个词法作用域的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my class Journey &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这在嵌套类中很有用。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性存在于每个类的实例中。属性中存储着对象的状态。在 Perl 6 中, 一切属性都是<code>私有的</code>.  它们一般使用 <code>has</code> 关键字和 <code>!</code> twigil 进行声明.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $!origin;</div><div class="line">    has $!destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $!notes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 没有像这样的公共(甚至保护属性)属性, 不过有一种方式能<code>自动生成访问方法</code>: 使用 <code>.</code>代替 <code>!</code> twigil 。(那个 <code>.</code> 应该让你想起了<strong>方法调用</strong>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这默认提供了一种<strong>只读</strong>的取值方法, 为了允许更改属性, 要添加 <code>is rw</code> 特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为类默认继承于构造器 <code>Mu</code>, 我们也要求类为我们生成一些<strong>存取方法</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 创建一个新的类的实例.</div><div class="line">my $vacation = Journey.new(</div><div class="line">    origin      =&gt; &apos;Sweden&apos;,</div><div class="line">    destination =&gt; &apos;Switzerland&apos;,</div><div class="line">    notes       =&gt; &apos;Pack hiking gear!&apos;</div><div class="line">);</div><div class="line"># 使用存取器; 这打印出 Sweden.</div><div class="line">say $vacation.origin;</div><div class="line"># 使用 rw 存取器来更改属性的值.</div><div class="line">$vacation.notes = &apos;Pack hiking gear and sunglasses!&apos;;</div></pre></td></tr></table></figure>
<p>注意, 默认的构造器只会设置含有存取器方法的属性.</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>使用 <code>method</code> 关键字定义类中的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Journey &#123;</div><div class="line">    has $.origin;</div><div class="line">    has $.destination;</div><div class="line">    has @!travellers;</div><div class="line">    has $.notes is rw;</div><div class="line"></div><div class="line">    method add_traveller($name) &#123;</div><div class="line">        if $name ne any(@!travellers) &#123;</div><div class="line">            push @!travellers, $name;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            warn &quot;$name is already going on the journey!&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method describe() &#123;</div><div class="line">        &quot;From $!origin to $!destination&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法可以有签名, 就像子例程一样。 方法中能访问对象的属性,  并且总是能使用 <code>!</code> twigil, 即使属性是用 <code>.</code> twigil 声明的. 这是因为, . twigil 是在那个位置上使用 ! twigil 声明了属性, 然后额外又添加了一个取值器方法.</p>
<p>即 <code>has $.attribute</code> 等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">has $!attribute</div><div class="line">method attribute() &#123; ... &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class A &#123;    </div><div class="line">    has $.attr is rw;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A &#123;    </div><div class="line">    has $!attr;    </div><div class="line">    method attr() is rw &#123;</div><div class="line">        $!attr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 describe 方法中使用 $!origin 和 $.origin ,这之间有一个微小但很重要的差别.  $!origin 只是属性的简单查看. 它是廉价的, 并且你知道它是类中声明的属性. $.origin 真正的是一个方法调用, 因此能在子类中被覆写. 如果你真的显式地要覆写它才使用 $.origin 吧.</p>
<h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>在方法内部, self 是可用的, 它被绑定到调用者, 例如方法调用的对象. self 能用于在调用者上调用深层的方法, 例如:</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>在方法的名字前面引入一个感叹号, 这个方法就变为类的私有方法, 这个方法只在内的内部使用, 不能在其它任何地方调用.</p>
<p>私有方法的调用要使用感叹号而非点号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">method !do-something-private($x) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">method public($x) &#123;</div><div class="line">    if self.precondition &#123;</div><div class="line">        self!do-something--private(2 * $x)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>私有方法不能被子类继承.</p>
<h3 id="子方法"><a href="#子方法" class="headerlink" title="子方法"></a>子方法</h3><p>submethod  是不会被子类继承的公开方法。从词干名来看它们在语义上与子例程类似。</p>
<p>Submethods 对于对象构建和解构任务很有用。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类可以有父类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Child is Parent1 is Parent2 &#123; &#125;</div></pre></td></tr></table></figure>
<p>如果在子类中调用一个方法, 但是子类没有提供那个方法, 就会调用父类中同名的方法, 如果父类中存在那个方法的话. 父类被询问的顺序就叫做方法解析顺序(MRO). Perl 6 使用 C3 方法解析顺序. 你可以通过调用一个类型的元类型方法得知这个类型的 MRO.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say Parcel.^mro;    # Parcel() Cool() Any() Mu()</div></pre></td></tr></table></figure>
<p>如果一个类没有指定它的父类, 就假定默认为 <code>Any</code>. 所有的类都直接或间接的派生于 Mu-类型层级的根.</p>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><p>对象通常通过方法调用创建, 或者通过类型对象或者通过同类型的其它对象创建. 类 Mu 提供了一个叫做 new 的构造器方法, 这个方法接收命名参数然后使用它们来初始化公共属性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y = 2 * $!x;</div><div class="line">&#125;</div><div class="line">my $p = Point.new( x =&gt; 1, y =&gt; 2);</div><div class="line">#             ^^^ 继承自类 Mu</div></pre></td></tr></table></figure>
<p><code>Mu.new</code> 在调用者身上调用 <code>bless</code> 方法, 传递所有的具名参数. bless 创建新的对象, 然后调用该对象的 <code>BUILDALL</code> 方法.  <strong>BUILDALL</strong> 以<code>相反的</code>方法解析顺序(继承层级树自上而下)遍历所有子类(例如, 从 Mu 到 派生类), 并且在每个类中检查名为 <code>BUILD</code> 的方法是否存在。 如果存在就调用它, 再把传递给 new 方法的所有具名参数传递给这个 <code>BUILD</code> 方法。 如果没有, 这个类的公开属性就会用<code>同名的</code>具名参数进行初始化.  这两种情况下, 如果 <strong>BULID</strong> 方法和 <strong>默认构造函数</strong> 都没有对属性进行初始化, 就会应用默认值 (上面例子中的 <code>2 * $!x</code>)。</p>
<p>这种构造模式对于自定义构造器有几处暗示. 首先, 自定义 BUILD 方法应该总是子方法(submethod), 否则它们会中断子类中的属性初始化. 第二, BUILD 子方法能用于在对象构造时执行自定义代码. 它们也能用于为属性初始化<strong>创建别名</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class EncodedBuffer &#123;</div><div class="line">    has $.enc;</div><div class="line">    has $.data;</div><div class="line"></div><div class="line">    submethod BUILD(:encoding(:$enc), :$data) &#123;</div><div class="line">        $!enc  := $enc;</div><div class="line">        $!data := $data;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">my $b1 = EncodedBuffer.new( encoding =&gt; &apos;UTF-8&apos;, data =&gt; [64, 65] );</div><div class="line">my $b2 = EncodedBuffer.new( enc      =&gt; &apos;UTF-8&apos;, data =&gt; [64, 65] );</div><div class="line">#  现在 enc 和 encoding 都被允许</div></pre></td></tr></table></figure>
<p>因为传递实参给子例程把实参绑定给了形参, 如果把属性用作形参,单独绑定那一步就不需要了. 所以上面的例子可以写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">submethod BUILD(:encoding(:$!enc), :$!data) &#123;</div><div class="line">    # nothing to do here anymore, the signature binding</div><div class="line">    # does all the work for us.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三个暗示是如果你想要一个接收位置参数的构造函数, 你必须自己写 new 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">    method new($x, $y) &#123;</div><div class="line">        self.bless(*, :$x, :$y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而, 这不是最佳实践, 因为这让来自子类的对象的初始化正确更难了.</p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><p>Roles 在某种程度上和类相似, 它们都是属性和方法的集合. 不同之处在于,  roles 是用来描述对象行为的某<strong>一部分</strong>的, 和 roles 怎样应用于类中. 或怎样解析。 类用于管理对象实例, 而 roles 用于<strong>管理行为</strong>和<strong>代码复用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">role Serializable &#123;</div><div class="line">    method serialize() &#123;</div><div class="line">        self.perl; # 很粗超的序列化</div><div class="line">    &#125;</div><div class="line">    method deserialization-code($buf) &#123;</div><div class="line">        EVAL $buf; #  反转 .perl 操作</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Point does Serializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line">my $p = Point.new(:x(1), :y(2));</div><div class="line">my $serialized = $p.serialize;      # 由 role 提供的方法</div><div class="line">my $clone-of-p = Point.deserialization-code($serialized);</div><div class="line">say $clone-of-p.x;      # 1</div></pre></td></tr></table></figure>
<p>编译器一解析到 role 声明的闭合花括号, roles 就不可变了。</p>
<h2 id="Role-Application"><a href="#Role-Application" class="headerlink" title="Role Application"></a>Role Application</h2><p>Role 应用和类继承有重大不同。 当 role 应用到类中时, 那个 role 的方法被复制到类中。如果多个 roles 被应用到同一个类中, 冲突( 例如同名的非 multi 方法(s) )会导致编译时错误, 这可以通过在类中提供一个同名的方法来解决冲突。<br>这比多重继承更安全, 在冲突从来不会被编译器检测到的地方, 但是代替的是借助于在 MRO 中出现更早的父类, 这可能是也可能不是程序员想要的。</p>
<p>当一个 role 被应用到第二个 role上, 实际的程序被延迟直到第二个 role 被应用到类, 这时两个 roles 才都被应用到那个类中。 因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">role R1 &#123;</div><div class="line">    # methods here</div><div class="line">&#125;</div><div class="line">role R2 does R1 &#123;</div><div class="line">    # methods here</div><div class="line">&#125;</div><div class="line">class C does R2 &#123; &#125;</div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">role R1 &#123;</div><div class="line">    <span class="comment"># methods here</span></div><div class="line">&#125;</div><div class="line">role R2 &#123;</div><div class="line">    <span class="comment"># methods here</span></div><div class="line">&#125;</div><div class="line">class C does R2 does R1 &#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="Stubs"><a href="#Stubs" class="headerlink" title="Stubs"></a>Stubs</h2><p>当 role 中包含了一个 stubbed 方法, 在这个 role 被应用到类中时, 必须提供一个同名的非 stubbed 版本的方法。这允许你创建如抽象接口那样的 roles。这有点像 Swift 中的 Protocol 协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">role AbstractSerializable &#123;</div><div class="line">    method serialize() &#123; ... &#125;  # 字面的三个点 ... 把方法标记为 stub</div><div class="line">&#125;</div><div class="line"></div><div class="line">#  下面是一个编译时错误, 例如</div><div class="line">#        Method &apos;serialize&apos; must be implemented by APoint because</div><div class="line">#        it is required by a role</div><div class="line">class APoint does AbstractSerializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 这个有效:</div><div class="line">class SPoint does AbstractSerializable &#123;</div><div class="line">    has $.x;</div><div class="line">    has $.y;</div><div class="line">    method serialize() &#123; &quot;p($.x, $.y)&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那个 stubbed 方法的实现也可能由另外一个 role 提供。</p>
<p>TODO: 参数化的 roles</p>
<h2 id="元对象编程和自省"><a href="#元对象编程和自省" class="headerlink" title="元对象编程和自省"></a>元对象编程和自省</h2><p>Perl 6 有一个元对象系统, 这意味着对象,类,roles,grammars,enums 它们自身的行为都被其它对象控制; 那些对象叫做元对象(想想元操作符, 它操作的对象是普通操作符). 元对象, 像普通对象一样,  是类的实例, 这时我们称它们为元类.</p>
<p>对每个对象或类, 你能通过调用 <code>.HOW</code>方法获取元对象. 注意, 尽管这看起来像是一个方法调用, 然而它实际上是编译器中的特殊案列, 所以它更像一个 macro.</p>
<p>所以, 你能用元对象干些什么呢? 你可以通过比较元类的相等性来检查两个对象是否具有同样的元类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 1.HOW ===   2.HOW;      # True</div><div class="line">say 1.HOW === Int.HOW;      # True</div><div class="line">say 1.HOW === Num.HOW;      # False</div></pre></td></tr></table></figure>
<p>Perl 6 使用单词 <code>HOW</code>, Higher Order Workings, 来引用元对象系统. 因此, 在 Rakudo 中不必对此吃惊, 控制类行为的元类的类名叫做 <code>Perl6::Metamodel::ClassHow</code>. 每个类都有一个 <code>Perl6::Metamodel::ClassHOW</code>的实例.</p>
<p>但是,理所当然的, 元模型为你做了很多. 例如它允许你内省对象和类.  元对象方法调用的约定是, 在元对象上调用方法, 并且传递感兴趣的对象作为对象的第一参数. 所以, 要获取对象的类名, 你可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my $object = 1;</div><div class="line">my $metaobject = 1.HOW;</div><div class="line">say $metaobject.name($object);      # Int</div><div class="line"># or shorter:</div><div class="line">say 1.HOW.name(1);                  # Int</div></pre></td></tr></table></figure>
<p>为了避免使用同一个对象两次, 有一个便捷写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">say 1.^name;                        # Int</div><div class="line"># same as</div><div class="line">say 1.HOW.name(1);                  # Int</div></pre></td></tr></table></figure>
<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>内省就是在运行时获取对象或类的信息的过程. 在 Perl 6 中,  所有的内省都会搜查原对象. 标准的基于类对象的 ClassHow 提供了这些工具:</p>
<h3 id="can"><a href="#can" class="headerlink" title="can"></a>can</h3><p>给定一个方法名, 它返回一个Parcel, 这个 Parcel 里面是可用的方法名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A      &#123; method x($a) &#123;&#125; &#125;;</div><div class="line">class B is A &#123; method x()   &#123;&#125; &#125;;</div><div class="line">say B.^can(&apos;x&apos;).elems;              # 2</div><div class="line">for B.^can(&apos;x&apos;) &#123;</div><div class="line">    say .arity;                     # 1, 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中, 类 B 中有两个名为 x 的方法可能可用(尽管一个正常的方法调用仅仅会直接调用安置在 B 中那个方法). B 中的那个方法有一个参数(例如, 它期望一个参数, 一个调用者(self)), 而 A 中的 x 方法期望 2 个参数( self 和 $a).</p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><hr>
<p>返回类中可用公共方法的列表( 这包括父类和 roles 中的方法). 默认它会停在类 Cool, Any 或 Mu 那儿; 若真要获取所有的方法, 使用副词 <code>:all</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">    method x() &#123; &#125;;</div><div class="line">&#125;</div><div class="line">say A.^methods();                   # x</div><div class="line">say A.^methods(:all);               # x infinite defined ...</div></pre></td></tr></table></figure>
<h3 id="mro"><a href="#mro" class="headerlink" title="mro"></a>mro</h3><p>按方法解析顺序返回类自身的列表和它们的父类.  当方法被调用时, 类和它的父类按那个顺序被访问.(仅仅是概念上; 实际上方法列表在类构建是就创建了).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say 1.^mro;                         # (Int) (Cool) (Any) (Mu)</div></pre></td></tr></table></figure>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>返回类的名字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say &apos;a string&apos;.^name;               # Str</div></pre></td></tr></table></figure>
<h3 id="parents"><a href="#parents" class="headerlink" title="parents"></a>parents</h3><p>返回一个父类的列表. 默认它会停在 Cool, Any 或者 Mu 那儿, 但你可以提供一个副词 <code>:all</code>来压制它. 使用副词 <code>:tree</code> 会返回一个嵌套列表.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class D             &#123; &#125;;</div><div class="line">class C1 is D       &#123; &#125;;</div><div class="line">class C2 is D       &#123; &#125;;</div><div class="line">class B is C1 is C2 &#123; &#125;;</div><div class="line">class A is B        &#123; &#125;;</div><div class="line">say A.^parents(:all).perl;          # (B, C1, C2, D, Any, Mu)</div><div class="line">say A.^parents(:all, :tree).perl;</div><div class="line">    # ([B, [C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]]],)</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>
    
    <div>
      
        
<div style="text-align:center;color: #ccc;font-size:15px;">
------ Young For Perl 6! ------</div>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面向对象/" rel="tag">#面向对象</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/14/正则表达式一例/" rel="next" title="正则表达式一例">
                <i class="fa fa-chevron-left"></i> 正则表达式一例
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/06/18/找到两个文件中共有的行/" rel="prev" title="找到两个文件中共有的行">
                找到两个文件中共有的行 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2015/06/15/面向对象的Perl6/"
     data-title="面向对象的 Perl 6"
     data-content=""
     data-url="https://ohmycloud.github.io/2015/06/15/面向对象的Perl6/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/06/15/面向对象的Perl6/"
           data-title="面向对象的 Perl 6" data-url="https://ohmycloud.github.io/2015/06/15/面向对象的Perl6/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="焉知非鱼" />
          <p class="site-author-name" itemprop="name">焉知非鱼</p>
          <p class="site-description motion-element" itemprop="description">Young For Perl 6</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">161</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">177</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ohmycloud" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/740011611" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/9b20c7d63b77" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-location-arrow"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://perl6.org/" target="_blank" title="Perl 6">
                  
                    <i class="fa fa-fw fa-paper-plane"></i>
                  
                  Perl 6
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用对象"><span class="nav-number">1.</span> <span class="nav-text">使用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型对象"><span class="nav-number">2.</span> <span class="nav-text">类型对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">3.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">4.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">5.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#self"><span class="nav-number">6.</span> <span class="nav-text">self</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#私有方法"><span class="nav-number">6.1.</span> <span class="nav-text">私有方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子方法"><span class="nav-number">6.2.</span> <span class="nav-text">子方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">7.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象构造"><span class="nav-number">8.</span> <span class="nav-text">对象构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Roles"><span class="nav-number">9.</span> <span class="nav-text">Roles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Role-Application"><span class="nav-number">10.</span> <span class="nav-text">Role Application</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stubs"><span class="nav-number">11.</span> <span class="nav-text">Stubs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元对象编程和自省"><span class="nav-number">12.</span> <span class="nav-text">元对象编程和自省</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内省"><span class="nav-number">13.</span> <span class="nav-text">内省</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#can"><span class="nav-number">13.1.</span> <span class="nav-text">can</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#methods"><span class="nav-number">13.2.</span> <span class="nav-text">methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mro"><span class="nav-number">13.3.</span> <span class="nav-text">mro</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name"><span class="nav-number">13.4.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parents"><span class="nav-number">13.5.</span> <span class="nav-text">parents</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">焉知非鱼</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  托管在 -
  <a class="theme-link" href="https://github.com/ohmycloud/ohmycloud.github.io">
    Github
  </a>
  &nbsp; | &nbsp;
</div>

<div class="theme-info">
 <a class="51-img" href="/images/footer.gif" target="_blank"><img alt="统计" src="/images/footer.gif"  align="right" /></a>
<div>
        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"chenyf"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  

</body>
</html>
